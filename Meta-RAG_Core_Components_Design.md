# Meta-RAG 시스템 핵심 컴포넌트 설계

**문서 버전: 1.0**
**작성일: 2025-10-22**

---

## 1. 문서 개요

본 문서는 Meta-RAG 시스템의 고수준 아키텍처를 구성하는 핵심 컴포넌트들을 식별하고, 각 컴포넌트의 역할과 책임을 정의합니다. 이는 향후 상세 클래스, 인터페이스, 함수 설계를 위한 기반이 됩니다.

## 2. 시스템 아키텍처 개요

Meta-RAG 시스템은 크게 **데이터 처리, 지식 저장, 검색, 추론, 피드백, 그리고 외부 인터페이스**의 여섯 가지 주요 영역으로 나눌 수 있습니다. 각 영역은 하나 이상의 핵심 컴포넌트로 구성됩니다.

```
[사용자 입력 (문제, 수식, 로그)]
        |
        V
[1. 데이터 수집 및 임베딩 레이어]
        |
        V
[2. 지식 저장 레이어 (Vector DB, Graph DB)] <-----> [3. 검색 레이어]
        ^                                                 |
        |                                                 V
[5. 피드백 및 강화 학습 레이어] <-------------------- [4. 추론 레이어 (LLM Reasoner)]
        ^                                                 |
        |                                                 V
[6. API 게이트웨이 / 백엔드 서비스 레이어] <-------- [프론트엔드 (Cognitive Flow UI)]
```

## 3. 핵심 컴포넌트 상세 정의

### 3.1. 데이터 수집 및 임베딩 레이어 (Data Ingestion & Embedding Layer) - Advanced Embedding Layer
**역할:** 사용자 입력(문제, 수식, 로그)을 수집하고, 시스템이 이해하고 처리할 수 있는 형태로 정교하게 분리 및 변환(임베딩)합니다.
**주요 책임:**
-   다양한 출처와 레이아웃의 문제를 구조화된 데이터로 분리
-   수식과 텍스트(문제 맥락)를 분리하여 각각 전문적으로 임베딩
-   생성된 이중 임베딩을 지식 저장 레이어로 전송

**1단계: 지능형 문제 파서 (Intelligent Problem Parser)**
**역할:** 다양한 출처(예: '회사명_문제유형')와 레이아웃의 문제를 입력받아 구조화된 데이터로 분리합니다.
**기술:** 정규표현식(Regex)과 패턴 매칭을 활용하여 문제의 텍스트 영역과 수식 영역을 정확하게 분리하고, 문제의 출처와 같은 메타데이터를 추출합니다. 이 파서는 각 문제 포맷에 맞춰 쉽게 확장할 수 있도록 모듈식으로 설계합니다.
**예상되는 주요 클래스/모듈:**
-   `ProblemParser`
-   `RegexPatternMatcher`
-   `MetadataExtractor`

**2단계: 이중 임베딩 전략 (Dual Embedding Strategy)**
**목표:** 문제의 '맥락'과 '논리'를 분리하여 더 정교하게 유사성을 파악합니다.
**구성:**
-   **수식 임베딩 모델 (Formula Embedding Model):** 분리된 수식(Formula) 데이터만을 전문적으로 벡터화합니다. 이를 통해 수학적, 논리적 구조가 유사한 문제들을 효과적으로 찾아낼 수 있습니다.
-   **문맥 임베딩 모델 (Context Embedding Model):** 수식을 제외한 나머지 텍스트(문제 설명, 조건 등)를 벡터화하여 문제의 배경이나 스토리텔링이 유사한 문제들을 찾아냅니다.
**기대 효과:** 이러한 이중 임베딩 전략은 단순히 텍스트 유사도를 넘어, 문제를 해결하는 데 필요한 논리적 구조와 배경 지식을 동시에 고려할 수 있게 만들어 Meta-RAG 시스템의 검색(Retrieval) 정확도를 획기적으로 높일 것입니다.
**예상되는 주요 클래스/모듈:**
-   `FormulaEncoder` (수식 전문 임베딩)
-   `ContextEncoder` (문맥 전문 임베딩)
-   `DualEmbeddingService` (두 임베딩 통합 관리)
-   `LogProcessor` (사고 과정 로그 처리)
-   `EmbeddingService` (전반적인 임베딩 서비스 관리)

### 3.2. 지식 저장 레이어 (Knowledge Base / Storage Layer)
**역할:** 임베딩된 데이터와 개념 간의 관계 그래프를 저장하고 관리합니다.
**주요 책임:**
-   고차원 벡터 데이터 저장 및 인덱싱
-   개념, 관계, 사고 과정 노드 및 엣지 저장
-   데이터의 일관성 및 무결성 유지
**예상되는 주요 클래스/모듈:**
-   `VectorDBManager` (FAISS, Milvus, Weaviate 등)
-   `GraphDBManager` (Neo4j, NetworkX 등)
-   `DataSynchronizer` (Vector DB와 Graph DB 간 동기화)

### 3.3. 검색 레이어 (Retrieval Layer)
**역할:** 현재 문제 또는 사고 과정과 관련된 유사한 지식(벡터) 및 사고 패턴(그래프)을 지식 저장 레이어에서 검색합니다.
**주요 책임:**
-   입력 쿼리(임베딩) 기반의 벡터 유사도 검색
-   그래프 탐색을 통한 관련 개념 및 사고 패턴 검색
-   검색된 결과를 추론 레이어로 전달
**예상되는 주요 클래스/모듈:**
-   `EmbeddingRetriever`
-   `GraphRetriever`
-   `CognitivePatternMatcher` (벡터 및 그래프 검색 결과 통합)

### 3.4. 추론 레이어 (Reasoning Layer - Algorithmization Core) - 알고리즘 기반 사고 과정 생성
**역할:** 검색된 정보를 바탕으로 새로운 사고 과정(Reasoning Chain)을 생성하고, 문제 해결 절차를 알고리즘화합니다. 시스템의 '두뇌' 역할을 하며, Meta-RAG를 '인지 학습 시스템'으로 만드는 핵심 아이디어입니다.
**주요 책임:**
-   LLM API와의 연동 및 프롬프트 엔지니어링
-   주어진 문제를 하위 문제로 분해하는 '분할 정복' 철학 적용
-   문제 해결을 위한 단계별 알고리즘(분할 정복, 백트래킹 등) 생성 및 실행 계획 수립
-   생성된 사고 과정의 유효성 검증

**핵심 철학: 분할 정복 (Divide and Conquer)**
**전제:** "아무리 복잡한 문제라도 결국에는 내가 이해할 수 있는 더 작은 문제들의 조합이다."
**실행:** LLM 추론 엔진은 주어진 문제를 해결하기 위해 곧바로 답을 내는 것이 아니라, 문제를 더 작은 단위의 하위 문제(Sub-problem)로 분해하는 작업을 우선적으로 수행합니다.

**알고리즘 적용:**
-   **분할 정복 (Divide and Conquer):** 문제를 독립적인 하위 문제로 나누고, 각 하위 문제의 해답을 구한 뒤 이를 조합하여 최종 답을 도출하는 사고 과정을 생성합니다.
-   **백트래킹 (Backtracking):** 가능한 모든 해결 경로를 탐색하다가 막히면 이전 단계로 돌아가 다른 경로를 시도하는 방식의 사고 과정을 시뮬레이션합니다. 이는 "이 방법이 안되네? 그럼 다른 방법으로 풀어볼까?" 하는 실제 학습자의 사고 과정을 그대로 보여줍니다.

**기대 효과: 노하우의 프랜차이즈화**
이 방식은 소수의 뛰어난 사람만 가지고 있던 문제 해결 노하우(블랙박스)를 누구나 따라 할 수 있는 명확한 절차(알고리즘)로 바꾸어 줍니다. 이는 마치 뛰어난 셰프의 레시피를 표준화하여 어느 지점에서나 동일한 맛을 내는 '프랜차이즈'처럼, 학생 개개인의 편차와 상관없이 일정 수준 이상의 학습 성과를 보장할 수 있는 강력한 교육 도구가 될 것입니다.

**예상되는 주요 클래스/모듈:**
-   `LLMReasoner`
-   `ProblemDecomposer` (분할 정복 로직 구현)
-   `AlgorithmizationEngine` (알고리즘 기반 사고 과정 생성)
-   `ReasoningOrchestrator`
-   `ThoughtProcessValidator`

### 3.5. 피드백 및 강화 학습 레이어 (Feedback & Reinforcement Layer)
**역할:** 추론 레이어에서 생성된 사고 과정의 결과와 사용자 피드백을 평가하고, 이를 통해 시스템의 성능을 지속적으로 개선합니다.
**주요 책임:**
-   생성된 결과에 대한 보상(Reward) 점수 계산
-   사용자 피드백 수집 및 분석
-   강화 학습(Reinforcement Learning) 메커니즘을 통한 모델 및 추론 전략 업데이트
-   지식 저장 레이어의 데이터 업데이트 트리거
**예상되는 주요 클래스/모듈:**
-   `RewardEvaluator`
-   `FeedbackProcessor`
-   `ReinforcementLearner`
-   `ModelUpdater`

### 3.6. API 게이트웨이 / 백엔드 서비스 레이어 (API Gateway / Backend Service Layer)
**역할:** 프론트엔드 및 외부 시스템과의 통신을 위한 인터페이스를 제공하고, 내부 컴포넌트들의 기능을 통합하여 노출합니다.
**주요 책임:**
-   RESTful API 또는 WebSocket 인터페이스 제공
-   요청 라우팅 및 인증/인가 처리
-   내부 컴포넌트 간의 데이터 흐름 조정 및 오케스트레이션
-   로그 및 모니터링 데이터 수집
**예상되는 주요 클래스/모듈:**
-   `MetaRAG_API` (FastAPI 애플리케이션)
-   `RequestAuthenticator`
-   `ServiceOrchestrator`
-   `Logger`

---

## 4. 다음 단계

이 핵심 컴포넌트 정의를 바탕으로, 각 컴포넌트 내에서 필요한 클래스, 인터페이스, 주요 함수들을 더 상세하게 설계하고 의사 코드 수준의 문서를 작성할 예정입니다.
