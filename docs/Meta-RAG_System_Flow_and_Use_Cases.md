# Meta-RAG v2: 전체 시스템 흐름 및 주요 사용 사례

이 문서는 Meta-RAG v2 아키텍처의 전체 흐름(End-to-End Flow)과 주요 액터(Actor) 별 사용 사례(Use Case)를 설명하여 시스템에 대한 상위 레벨의 이해를 돕는 것을 목표로 합니다.

## 1. v2 아키텍처 요약

Meta-RAG v2는 **Managed Service 우선 아키텍처**를 채택하여, 무거운 연산과 데이터 관리를 GCP의 전문 서비스에 위임합니다. 애플리케이션(Cloud Run)은 이 서비스들을 조율하는 가벼운 오케스트레이터 역할에 집중하여, 높은 확장성과 안정성, 그리고 유지보수성을 확보합니다.

---

## 2. 주요 액터 (Actors)

-   **최종 사용자 (End-User)**: RAG 시스템에 질문하여 답변을 얻는 주체입니다. (예: 학생)
-   **개발자 (Developer)**: 시스템을 유지보수하고, 새로운 기능을 개발하며, 배포하는 주체입니다.

---

## 3. 주요 사용 사례 (Key Use Cases)

### 가. 사용 사례 1: 최종 사용자의 질문 및 답변 과정

-   **액터**: 최종 사용자
-   **목표**: 질문을 하고, 빠르고 정확하며 개인화된 답변을 받는다.

**✅ v2 전체 흐름 (End-to-End Flow):**

1.  **인증 및 요청**: 사용자가 클라이언트 앱에서 로그인 후 발급받은 **JWT**를 담아 API를 요청합니다.
2.  **엣지 보안 (Cloudflare)**: 요청은 가장 먼저 **Cloudflare**에 도달하여, WAF/DDoS 등 보안 위협이 필터링됩니다.
3.  **API Gateway (GCP)**: Cloudflare를 통과한 요청은 **GCP API Gateway**에 도착하여 **JWT가 검증**됩니다. 유효하지 않은 토큰은 여기서 차단됩니다.
4.  **오케스트레이터 (Cloud Run)**: 인증된 요청이 백엔드 **Cloud Run (FastAPI)** 서비스에 도착합니다. 여기서부터 비즈니스 로직이 시작됩니다.
    a.  (필요시) JWT payload를 확인하여 사용자 등급(`tier`) 등 개인화 정보를 확인합니다.
    b.  사용자의 질문(Query)을 **Vertex AI Endpoint**에 보내 임베딩 벡터를 받아옵니다.
5.  **정보 검색 (Retrieval)**:
    a.  변환된 벡터를 **Vertex AI Matching Engine**에 보내 유사도가 높은 관련 문서를 검색합니다.
    b.  동시에, 질문의 핵심 엔티티를 추출하여 **Neo4j AuraDB**에 보내 관련 지식 그래프를 조회합니다.
6.  **답변 생성 (Generation)**: 검색된 문서와 그래프 정보를 원본 질문과 함께 조합하여, **Vertex AI Endpoint(LLM)** 에 프롬프트로 전달합니다.
7.  **응답**: LLM이 생성한 최종 답변이 역순으로 사용자에게 전달됩니다.

![v2 System Flow Diagram](https://gist.github.com/assets/3687397/989c5b14-a50f-4fa6-a15a-a355a634f52f/raw/d35d34a610c5905a366d542d0b990d44337fbf2b/meta-rag-flow-v2.svg)

### 나. 사용 사례 2: 개발자의 인프라 및 애플리케이션 배포

-   **액터**: 개발자
-   **목표**: 인프라 변경과 애플리케이션 업데이트를 코드 기반으로 안전하고 자동화하여 배포한다.

**✅ IaC 및 CI/CD 흐름 (Infrastructure & CI/CD Flow):**

1.  **코드 작성**: 개발자는 두 종류의 코드를 작성합니다.
    -   **인프라 코드 (Terraform)**: GCP 리소스(Cloud Run, Vertex AI 등)의 구성을 `.tf` 파일에 정의합니다.
    -   **애플리케이션 코드 (Python)**: FastAPI 오케스트레이터의 비즈니스 로직을 `.py` 파일에 작성합니다.
2.  **코드 푸시**: 개발자가 `main` 브랜치로 코드를 `git push` 합니다.
3.  **파이프라인 트리거**: GitHub Actions가 `push` 이벤트를 감지하고 CI/CD 파이프라인을 시작합니다.
4.  **애플리케이션 CI**: 애플리케이션 코드를 대상으로 `pytest`를 실행하여 무결성을 검증합니다.
5.  **이미지 빌드/푸시**: 테스트가 성공하면, 애플리케이션을 경량 Docker 이미지로 빌드하여 **Artifact Registry**에 푸시합니다.
6.  **인프라 배포 (IaC)**: 파이프라인이 `terraform apply` 명령을 실행합니다. Terraform은 현재 GCP 상태와 코드에 정의된 상태를 비교하여, 변경이 필요한 리소스(예: 새 이미지를 사용하도록 Cloud Run 서비스 업데이트)를 안전하게 적용합니다.
7.  **배포 완료**: 잠시 후, 변경된 인프라와 애플리케이션이 사용자에게 서비스됩니다.
